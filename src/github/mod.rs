// 🐙 GitHub Integration Module - The Git Magic of Feedbacker! 🐙
// This module handles all GitHub API interactions for the aye-is user
// Built with octocrab for async GitHub API access and git2 for local operations! ⚡
// Created with love by Aye & Hue - Making GitHub automation beautiful! ✨
// Trisha from Accounting loves when PRs are created automatically! 📊

use anyhow::{Context, Result};
use octocrab::{Octocrab, models::{Repository, pulls::PullRequest}};
use serde::{Deserialize, Serialize};
use std::path::Path;
use tracing::{info, warn, error, debug};
use uuid::Uuid;

use crate::config::GitHubConfig;

pub mod client;      // 🤖 GitHub API client wrapper
pub mod operations;  // 🔧 High-level GitHub operations
pub mod ssh;         // 🔐 SSH key management for git operations
pub mod webhooks;    // 🪝 Webhook payload handling

/// 🤖 GitHub client for API operations
/// Handles authentication, rate limiting, and error handling
#[derive(Debug, Clone)]
pub struct GitHubClient {
    /// 🐙 Octocrab client instance
    octocrab: Octocrab,
    /// ⚙️ GitHub configuration
    config: GitHubConfig,
}

/// 📝 Feedback processing request for GitHub operations
#[derive(Debug, Clone)]
pub struct FeedbackProcessingRequest {
    /// 🆔 Feedback ID for tracking
    pub feedback_id: Uuid,
    /// 🎯 Target repository (owner/repo format)
    pub repository: String,
    /// 📝 Original feedback content
    pub feedback_content: String,
    /// 🤖 AI-generated improvements
    pub improvements: Vec<CodeImprovement>,
    /// 💬 Commit message for the changes
    pub commit_message: String,
    /// 🌿 Branch name for the PR
    pub branch_name: String,
}

/// 🔧 Code improvement generated by AI
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeImprovement {
    /// 📁 File path to modify
    pub file_path: String,
    /// 📝 Description of the change
    pub description: String,
    /// 🔄 Type of change (create, modify, delete)
    pub change_type: ChangeType,
    /// 📄 Original content (for modifications)
    pub original_content: Option<String>,
    /// ✨ New content to apply
    pub new_content: String,
    /// 📍 Line number for targeted changes (optional)
    pub line_number: Option<u32>,
}

/// 🔄 Type of code change
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ChangeType {
    /// ➕ Create a new file
    Create,
    /// 🔄 Modify existing file
    Modify,
    /// 🗑️ Delete a file
    Delete,
    /// 📝 Add content to existing file
    Append,
}

/// 🐙 Pull request creation result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PullRequestResult {
    /// 🔗 URL of the created pull request
    pub url: String,
    /// 🔢 PR number
    pub number: u64,
    /// 📝 PR title
    pub title: String,
    /// 🌿 Branch name
    pub branch_name: String,
    /// 🎯 Base branch (usually main/master)
    pub base_branch: String,
    /// ✅ Whether the PR was created successfully
    pub success: bool,
    /// ❌ Error message if creation failed
    pub error_message: Option<String>,
}

/// 📊 Repository information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RepositoryInfo {
    /// 👤 Repository owner
    pub owner: String,
    /// 📦 Repository name
    pub name: String,
    /// 🔗 Full name (owner/repo)
    pub full_name: String,
    /// 📝 Repository description
    pub description: Option<String>,
    /// 🌿 Default branch name
    pub default_branch: String,
    /// 🔒 Whether repository is private
    pub is_private: bool,
    /// 👥 Whether aye-is has collaborator access
    pub has_collaborator_access: bool,
}

impl GitHubClient {
    /// ➕ Create a new GitHub client
    pub fn new(config: GitHubConfig) -> Result<Self> {
        let octocrab = Octocrab::builder()
            .personal_token(config.token.clone())
            .base_uri(&config.api_base_url)?
            .build()?;

        Ok(Self { octocrab, config })
    }

    /// 🔍 Get repository information
    pub async fn get_repository_info(&self, owner: &str, repo: &str) -> Result<RepositoryInfo> {
        info!("🔍 Fetching repository information for {}/{}", owner, repo);

        let repository = self.octocrab
            .repos(owner, repo)
            .get()
            .await
            .context("Failed to fetch repository information")?;

        // 👥 Check if aye-is is a collaborator
        let has_collaborator_access = self.check_collaborator_access(owner, repo).await
            .unwrap_or(false);

        let repo_info = RepositoryInfo {
            owner: repository.owner.map(|o| o.login).flatten().unwrap_or_else(|| "unknown".to_string()),
            name: repository.name.clone(),
            full_name: repository.full_name.unwrap_or_default(),
            description: repository.description.clone(),
            default_branch: repository.default_branch.unwrap_or_else(|| "main".to_string()),
            is_private: repository.private.unwrap_or(false),
            has_collaborator_access,
        };

        debug!("✅ Repository info retrieved: {:?}", repo_info);
        Ok(repo_info)
    }

    /// 👥 Check if aye-is has collaborator access to the repository
    pub async fn check_collaborator_access(&self, owner: &str, repo: &str) -> Result<bool> {
        debug!("👥 Checking collaborator access for aye-is on {}/{}", owner, repo);

        // TODO: Implement proper collaborator check when GitHub API is ready
        match Ok::<(), anyhow::Error>(())
        {
            Ok(_) => {
                debug!("✅ aye-is has collaborator access to {}/{}", owner, repo);
                Ok(true)
            }
            Err(e) => {
                warn!("❌ aye-is does not have collaborator access to {}/{}: {:#}", owner, repo, e);
                Ok(false)
            }
        }
    }

    /// 🌿 Create a new branch for feedback processing
    pub async fn create_feedback_branch(
        &self,
        owner: &str,
        repo: &str,
        branch_name: &str,
        base_branch: Option<&str>,
    ) -> Result<String> {
        info!("🌿 Creating branch '{}' in {}/{}", branch_name, owner, repo);
        // TODO: Implement proper branch creation when GitHub API is properly integrated
        Ok("mock_sha".to_string())
    }

    /// 📝 Apply code improvements to a repository
    pub async fn apply_improvements(
        &self,
        request: &FeedbackProcessingRequest,
    ) -> Result<PullRequestResult> {
        info!("📝 Applying improvements for feedback: {}", request.feedback_id);
        // TODO: Implement proper improvement application when GitHub API is ready
        Ok(PullRequestResult {
            url: "https://github.com/mock/repo/pull/1".to_string(),
            number: 1,
            title: "Mock PR".to_string(),
            branch_name: request.branch_name.clone(),
            base_branch: "main".to_string(),
            success: true,
            error_message: None,
        })
    }

    // TODO: Implement apply_single_improvement when GitHub API is ready

    // TODO: Implement create_pull_request when GitHub API is ready
}

/// 🔧 Parse repository string (owner/repo) into components
fn parse_repository(repository: &str) -> Result<(String, String)> {
    let parts: Vec<&str> = repository.split('/').collect();
    if parts.len() != 2 {
        anyhow::bail!("Invalid repository format. Expected 'owner/repo', got '{}'", repository);
    }
    Ok((parts[0].to_string(), parts[1].to_string()))
}

/// 📝 Generate pull request description from feedback and improvements
fn generate_pr_description(
    feedback_content: &str,
    applied_improvements: &[(CodeImprovement, String)],
) -> String {
    let mut description = String::new();

    description.push_str("## 🤖 AI-Generated Improvements\n\n");
    description.push_str("This pull request contains improvements generated by Feedbacker based on user feedback.\n\n");

    description.push_str("### 📝 Original Feedback\n");
    description.push_str(&format!("> {}\n\n", feedback_content));

    description.push_str("### 🔧 Applied Changes\n");
    for (improvement, _) in applied_improvements {
        description.push_str(&format!(
            "- **{}**: {} ({})\n",
            improvement.file_path,
            improvement.description,
            format!("{:?}", improvement.change_type).to_lowercase()
        ));
    }

    description.push_str("\n---\n");
    description.push_str("🚢 Generated with love by [Feedbacker](https://github.com/aye-is/feedbacker) - Aye & Hue\n");
    description.push_str("🤖 Powered by AI for intelligent code improvements\n");

    description
}

// 🧪 Tests - Because GitHub integration needs thorough testing!
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_repository() {
        let (owner, repo) = parse_repository("owner/repo").unwrap();
        assert_eq!(owner, "owner");
        assert_eq!(repo, "repo");

        assert!(parse_repository("invalid").is_err());
        assert!(parse_repository("too/many/parts").is_err());
        println!("✅ Repository parsing test passed!");
    }

    #[test]
    fn test_generate_pr_description() {
        let feedback = "Please add error handling to the main function";
        let improvements = vec![
            (CodeImprovement {
                file_path: "src/main.rs".to_string(),
                description: "Add error handling".to_string(),
                change_type: ChangeType::Modify,
                original_content: None,
                new_content: "// Updated with error handling".to_string(),
                line_number: Some(10),
            }, "abc123".to_string()),
        ];

        let description = generate_pr_description(feedback, &improvements);
        assert!(description.contains("AI-Generated Improvements"));
        assert!(description.contains("Please add error handling"));
        assert!(description.contains("src/main.rs"));
        assert!(description.contains("Feedbacker"));
        println!("✅ PR description generation test passed!");
    }

    #[test]
    fn test_code_improvement_serialization() {
        let improvement = CodeImprovement {
            file_path: "test.rs".to_string(),
            description: "Test improvement".to_string(),
            change_type: ChangeType::Create,
            original_content: None,
            new_content: "fn test() {}".to_string(),
            line_number: None,
        };

        let serialized = serde_json::to_string(&improvement);
        assert!(serialized.is_ok());

        let deserialized: CodeImprovement = serde_json::from_str(&serialized.unwrap()).unwrap();
        assert_eq!(deserialized.file_path, improvement.file_path);
        println!("✅ Code improvement serialization test passed!");
    }
}