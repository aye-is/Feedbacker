// ğŸ™ GitHub Integration Module - The Git Magic of Feedbacker! ğŸ™
// This module handles all GitHub API interactions for the aye-is user
// Built with octocrab for async GitHub API access and git2 for local operations! âš¡
// Created with love by Aye & Hue - Making GitHub automation beautiful! âœ¨
// Trisha from Accounting loves when PRs are created automatically! ğŸ“Š

use anyhow::{Context, Result};
use octocrab::{
    models::{pulls::PullRequest, Repository},
    Octocrab,
};
use serde::{Deserialize, Serialize};
use std::path::Path;
use tracing::{debug, error, info, warn};
use uuid::Uuid;

use crate::config::GitHubConfig;

pub mod client; // ğŸ¤– GitHub API client wrapper
pub mod operations; // ğŸ”§ High-level GitHub operations
pub mod ssh; // ğŸ” SSH key management for git operations
pub mod webhooks; // ğŸª Webhook payload handling

/// ğŸ¤– GitHub client for API operations
/// Handles authentication, rate limiting, and error handling
#[derive(Debug, Clone)]
pub struct GitHubClient {
    /// ğŸ™ Octocrab client instance
    octocrab: Octocrab,
    /// âš™ï¸ GitHub configuration
    config: GitHubConfig,
}

/// ğŸ“ Feedback processing request for GitHub operations
#[derive(Debug, Clone)]
pub struct FeedbackProcessingRequest {
    /// ğŸ†” Feedback ID for tracking
    pub feedback_id: Uuid,
    /// ğŸ¯ Target repository (owner/repo format)
    pub repository: String,
    /// ğŸ“ Original feedback content
    pub feedback_content: String,
    /// ğŸ¤– AI-generated improvements
    pub improvements: Vec<CodeImprovement>,
    /// ğŸ’¬ Commit message for the changes
    pub commit_message: String,
    /// ğŸŒ¿ Branch name for the PR
    pub branch_name: String,
}

/// ğŸ”§ Code improvement generated by AI
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeImprovement {
    /// ğŸ“ File path to modify
    pub file_path: String,
    /// ğŸ“ Description of the change
    pub description: String,
    /// ğŸ”„ Type of change (create, modify, delete)
    pub change_type: ChangeType,
    /// ğŸ“„ Original content (for modifications)
    pub original_content: Option<String>,
    /// âœ¨ New content to apply
    pub new_content: String,
    /// ğŸ“ Line number for targeted changes (optional)
    pub line_number: Option<u32>,
}

/// ğŸ”„ Type of code change
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ChangeType {
    /// â• Create a new file
    Create,
    /// ğŸ”„ Modify existing file
    Modify,
    /// ğŸ—‘ï¸ Delete a file
    Delete,
    /// ğŸ“ Add content to existing file
    Append,
}

/// ğŸ™ Pull request creation result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PullRequestResult {
    /// ğŸ”— URL of the created pull request
    pub url: String,
    /// ğŸ”¢ PR number
    pub number: u64,
    /// ğŸ“ PR title
    pub title: String,
    /// ğŸŒ¿ Branch name
    pub branch_name: String,
    /// ğŸ¯ Base branch (usually main/master)
    pub base_branch: String,
    /// âœ… Whether the PR was created successfully
    pub success: bool,
    /// âŒ Error message if creation failed
    pub error_message: Option<String>,
}

/// ğŸ“Š Repository information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RepositoryInfo {
    /// ğŸ‘¤ Repository owner
    pub owner: String,
    /// ğŸ“¦ Repository name
    pub name: String,
    /// ğŸ”— Full name (owner/repo)
    pub full_name: String,
    /// ğŸ“ Repository description
    pub description: Option<String>,
    /// ğŸŒ¿ Default branch name
    pub default_branch: String,
    /// ğŸ”’ Whether repository is private
    pub is_private: bool,
    /// ğŸ‘¥ Whether aye-is has collaborator access
    pub has_collaborator_access: bool,
}

impl GitHubClient {
    /// â• Create a new GitHub client
    pub fn new(config: GitHubConfig) -> Result<Self> {
        let octocrab = Octocrab::builder()
            .personal_token(config.token.clone())
            .base_uri(&config.api_base_url)?
            .build()?;

        Ok(Self { octocrab, config })
    }

    /// ğŸ” Get repository information
    pub async fn get_repository_info(&self, owner: &str, repo: &str) -> Result<RepositoryInfo> {
        info!("ğŸ” Fetching repository information for {}/{}", owner, repo);

        let repository = self
            .octocrab
            .repos(owner, repo)
            .get()
            .await
            .context("Failed to fetch repository information")?;

        // ğŸ‘¥ Check if aye-is is a collaborator
        let has_collaborator_access = self
            .check_collaborator_access(owner, repo)
            .await
            .unwrap_or(false);

        let repo_info = RepositoryInfo {
            owner: repository
                .owner
                .map(|o| o.login)  // ğŸ”§ Fixed: map returns Option<String>, which is what we want
                .unwrap_or_else(|| "unknown".to_string()),
            name: repository.name.clone(),
            full_name: repository.full_name.unwrap_or_default(),
            description: repository.description.clone(),
            default_branch: repository
                .default_branch
                .unwrap_or_else(|| "main".to_string()),
            is_private: repository.private.unwrap_or(false),
            has_collaborator_access,
        };

        debug!("âœ… Repository info retrieved: {:?}", repo_info);
        Ok(repo_info)
    }

    /// ğŸ‘¥ Check if aye-is has collaborator access to the repository
    pub async fn check_collaborator_access(&self, owner: &str, repo: &str) -> Result<bool> {
        debug!(
            "ğŸ‘¥ Checking collaborator access for aye-is on {}/{}",
            owner, repo
        );

        // TODO: Implement proper collaborator check when GitHub API is ready
        match Ok::<(), anyhow::Error>(()) {
            Ok(_) => {
                debug!("âœ… aye-is has collaborator access to {}/{}", owner, repo);
                Ok(true)
            }
            Err(e) => {
                warn!(
                    "âŒ aye-is does not have collaborator access to {}/{}: {:#}",
                    owner, repo, e
                );
                Ok(false)
            }
        }
    }

    /// ğŸŒ¿ Create a new branch for feedback processing
    pub async fn create_feedback_branch(
        &self,
        owner: &str,
        repo: &str,
        branch_name: &str,
        base_branch: Option<&str>,
    ) -> Result<String> {
        info!("ğŸŒ¿ Creating branch '{}' in {}/{}", branch_name, owner, repo);
        // TODO: Implement proper branch creation when GitHub API is properly integrated
        Ok("mock_sha".to_string())
    }

    /// ğŸ“ Apply code improvements to a repository
    pub async fn apply_improvements(
        &self,
        request: &FeedbackProcessingRequest,
    ) -> Result<PullRequestResult> {
        info!(
            "ğŸ“ Applying improvements for feedback: {}",
            request.feedback_id
        );
        // TODO: Implement proper improvement application when GitHub API is ready
        Ok(PullRequestResult {
            url: "https://github.com/mock/repo/pull/1".to_string(),
            number: 1,
            title: "Mock PR".to_string(),
            branch_name: request.branch_name.clone(),
            base_branch: "main".to_string(),
            success: true,
            error_message: None,
        })
    }

    // TODO: Implement apply_single_improvement when GitHub API is ready

    // TODO: Implement create_pull_request when GitHub API is ready
}

/// ğŸ”§ Parse repository string (owner/repo) into components
fn parse_repository(repository: &str) -> Result<(String, String)> {
    let parts: Vec<&str> = repository.split('/').collect();
    if parts.len() != 2 {
        anyhow::bail!(
            "Invalid repository format. Expected 'owner/repo', got '{}'",
            repository
        );
    }
    Ok((parts[0].to_string(), parts[1].to_string()))
}

/// ğŸ“ Generate pull request description from feedback and improvements
fn generate_pr_description(
    feedback_content: &str,
    applied_improvements: &[(CodeImprovement, String)],
) -> String {
    let mut description = String::new();

    description.push_str("## ğŸ¤– AI-Generated Improvements\n\n");
    description.push_str("This pull request contains improvements generated by Feedbacker based on user feedback.\n\n");

    description.push_str("### ğŸ“ Original Feedback\n");
    description.push_str(&format!("> {}\n\n", feedback_content));

    description.push_str("### ğŸ”§ Applied Changes\n");
    for (improvement, _) in applied_improvements {
        description.push_str(&format!(
            "- **{}**: {} ({})\n",
            improvement.file_path,
            improvement.description,
            format!("{:?}", improvement.change_type).to_lowercase()
        ));
    }

    description.push_str("\n---\n");
    description.push_str("ğŸš¢ Generated with love by [Feedbacker](https://github.com/aye-is/feedbacker) - Aye & Hue\n");
    description.push_str("ğŸ¤– Powered by AI for intelligent code improvements\n");

    description
}

// ğŸ§ª Tests - Because GitHub integration needs thorough testing!
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_repository() {
        let (owner, repo) = parse_repository("owner/repo").unwrap();
        assert_eq!(owner, "owner");
        assert_eq!(repo, "repo");

        assert!(parse_repository("invalid").is_err());
        assert!(parse_repository("too/many/parts").is_err());
        println!("âœ… Repository parsing test passed!");
    }

    #[test]
    fn test_generate_pr_description() {
        let feedback = "Please add error handling to the main function";
        let improvements = vec![(
            CodeImprovement {
                file_path: "src/main.rs".to_string(),
                description: "Add error handling".to_string(),
                change_type: ChangeType::Modify,
                original_content: None,
                new_content: "// Updated with error handling".to_string(),
                line_number: Some(10),
            },
            "abc123".to_string(),
        )];

        let description = generate_pr_description(feedback, &improvements);
        assert!(description.contains("AI-Generated Improvements"));
        assert!(description.contains("Please add error handling"));
        assert!(description.contains("src/main.rs"));
        assert!(description.contains("Feedbacker"));
        println!("âœ… PR description generation test passed!");
    }

    #[test]
    fn test_code_improvement_serialization() {
        let improvement = CodeImprovement {
            file_path: "test.rs".to_string(),
            description: "Test improvement".to_string(),
            change_type: ChangeType::Create,
            original_content: None,
            new_content: "fn test() {}".to_string(),
            line_number: None,
        };

        let serialized = serde_json::to_string(&improvement);
        assert!(serialized.is_ok());

        let deserialized: CodeImprovement = serde_json::from_str(&serialized.unwrap()).unwrap();
        assert_eq!(deserialized.file_path, improvement.file_path);
        println!("âœ… Code improvement serialization test passed!");
    }
}
